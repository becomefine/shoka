---
title: c++基础
date: 2022-07-19 14:48:10
categories:
 - [计算机科学, C/C++]
tags: 
 - C/C++
---

# 面试基础问题

## 1. 什么是内存泄漏，如何检测和避免

**内存泄漏**
一般指`堆内存的泄漏`。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序一般使用malloc、realloc、new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。

**避免内存泄漏的几种方式**
+ 计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄漏。
+ 一定要将基类的析构函数声明为虚函数
+ 对象数组的释放一定要用delete[]
+ 有new就有delete，有malloc就有free，保证他们一定成对出现



**检测工具**
- Linux下可以使用Valgrind工具
- Windows下可以使用CRT库

## 2. 对象复用的了解，零拷贝的了解

**对象复用**
对象复用本质是一种设计模式：Flyweight享元模式。
通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。
**零拷贝**
零拷贝就是一种避免CPU将数据从一块存储拷贝到另外一块存储的技术。减少数据拷贝和共享总线操作的次数。

在C++中，vector的一个成员函数**emplace_back()**很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：**使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造**，效率更高。


## 3. 面向对象的三大特性，并且举例说明。
三大特性：继承、封装和多态。
(1)**继承**
让某种类型对象获得另一个类型对象的属性和方法。
可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
常见的三种继承方式：
1. 实现集成：指使用基类的属性和方法而无需额外编码的能力。
2. 接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力。
3. 可视继承：指子窗体(类)使用基窗体(类)的外观和实现代码的能力(C++里好像不怎么用)。

(2)**封装**
数据和代码捆绑在一起，避免外界干扰和不确定性访问。
封装，也就是**把客观事物封装成抽象的类**，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。

(3)**多态**
同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为 **(重载实现编译时多态，虚函数实现运行时多态)**。
多态性是允许你将父对象设置称为和一个或更多的它的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单来说：**允许将子类类型的指针赋值给父类类型的指针**。

实现多态的两种方式：覆盖(override), 重载(overload)。
覆盖：是指子类重新定义父类的虚函数的做法。
重载：是指允许存在多个同名函数，而这些函数的参数表不同(或许参数个数不同，或许参数类型不同，或许两者都不同)。例如：基类是一个抽象对象————人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。

## 4.成员初始化列表的概念，为什么用它会快一些？

**成员初始化列表的概念**
在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值。
**效率**
用初始化列表会快一些的原因是，对于类型，它少了一次调用构造函数的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别。
```cpp
#include <iostream>
using namespace std;
class A
{
    public:
        A(){
            cout <<"默认构造函数A()" << endl;
        }
        A(int a){
            value = a;
            cout << "A(int " << value << ")" << endl;
        }
        A(const A& a){
            value = a.value;
            cout << "拷贝构造函数A(A& a): " << value << endl;
        }
        int value;
};

class B
{
    public:
        B(): a(1){
            b = A(2);
        }
        A a;
        A b;
};
//输出结果:
//A(int 1)
//默认构造函数A()
//A(int2)
```
在构造函数体内部初始化的对象b多了一次构造函数的调用过程，而对象a则没有。由于对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，但**如果有些成员是类**，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以**如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作**。

## 5.C++函数调用的压栈过程

```cpp
#include <iostream>
using namespace std;

int f(int n) 
{
	cout << n << endl;
	return n;
}

void func(int param1, int param2)
{
	int var1 = param1;
	int var2 = param2;
	printf("var1=%d,var2=%d", f(var1), f(var2));//如果将printf换为cout进行输出，输出结果则刚好相反
}

int main(int argc, char* argv[])
{
	func(1, 2);
	return 0;
}
//输出结果
//2
//1
//var1=1,var2=2
```

当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、main函数中的变量、进行依次压栈；
当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；
当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈。
从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2), 再执行f(var1), 最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。

**函数的调用过程：**
1) 从栈空间分配存储空间
2) 从实参的存储空间复制值到形参栈空间
3) 进行运算

形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。
数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。

当函数有多个返回值的时候，不能用普通的return的方式实现，需要通过传回地址的形式进行，即地址/指针传递。

## 6. 移动构造函数

1. 我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在(析构前)，拷贝构造函数实际上就是把a对象的内容复制一份到b中，直接使用a的空间可以避免新的空间的分配，降低构造的成本。
2. 拷贝构造函数中，对于指针，我们一定要采用深层赋值，而移动构造函数中，对于指针，我们采用浅层赋值。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。

:::primary
所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针(比如a->value)置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a->value指向的空间；
:::

3. 移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用，也就是说，只用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。

## 7. 静态类型、动态类型，静态绑定和动态绑定

- 静态类型：对象在声明时采用的类型，在编译期就已确定；
- 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；
- 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；
- 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

非虚函数一般都是静态绑定，虚函数都是动态绑定。

## 8. 全局变量和局部变量有什么区别？

生命周期不同：全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；

使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈去，只能在局部使用。

操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面。

## 9. 怎样判断两个浮点数是否相等？

对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。

## 10. 方法调用的原理(栈，汇编)

1. 机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈
可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp；
2. 由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。
3. 过程实现
1) 备份原来的帧指针，调整当前的帧栈指针到栈指针位置；
2) 建立起来的栈帧就是为被调用者准备的，当被调用者使用帧栈时，需要给临时变量分配预留内存；
3) 使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。
4) 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。
5) 释放被调动者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。
6) 恢复调用者的帧栈，恢复其实就是调整栈帧两段，使得当前栈帧的区域又回到了原始的位置。
7) 弹出返回地址，跳出当前过程，继续执行调用者的代码。

4. 过程调用和返回指令
1) call指令
2) leave指令
3) ret指令

## 11. C++中的指针参数传递和引用参数传递有什么区别？


